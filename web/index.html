<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BASTION - Risk Management</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
    <div class="dashboard">
        <!-- Header -->
        <header class="header">
            <div class="logo">BASTION</div>
            
            <div class="symbol-display">
                <span class="symbol-name" id="symbolName">BTCUSDT</span>
                <span class="symbol-price" id="symbolPrice">--</span>
                <span class="symbol-change" id="symbolChange">--%</span>
            </div>
            
            <div class="header-controls">
                <button class="timeframe-btn" data-tf="15m">15m</button>
                <button class="timeframe-btn" data-tf="1h">1H</button>
                <button class="timeframe-btn active" data-tf="4h">4H</button>
                <button class="timeframe-btn" data-tf="1d">1D</button>
            </div>
            
            <div class="live-indicator">
                <div class="live-dot"></div>
                <span>Live</span>
            </div>
        </header>
        
        <!-- Chart -->
        <div class="chart-container">
            <div id="chart"></div>
        </div>
        
        <!-- Sidebar -->
        <aside class="sidebar">
            <!-- Setup Form -->
            <section class="sidebar-section">
                <div class="section-title">Trade Setup</div>
                
                <div class="form-group">
                    <label class="form-label">Symbol</label>
                    <select class="form-input" id="inputSymbol">
                        <option value="BTCUSDT">BTCUSDT</option>
                        <option value="ETHUSDT">ETHUSDT</option>
                        <option value="SOLUSDT">SOLUSDT</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Direction</label>
                    <div class="direction-toggle">
                        <button class="direction-btn long active" id="btnLong">LONG</button>
                        <button class="direction-btn short" id="btnShort">SHORT</button>
                    </div>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Entry Price</label>
                    <input type="number" class="form-input" id="inputEntry" placeholder="Market price">
                </div>
                
                <div class="form-group">
                    <label class="form-label">Account Balance</label>
                    <input type="number" class="form-input" id="inputBalance" value="100000">
                </div>
                
                <div class="form-group">
                    <label class="form-label">Risk %</label>
                    <input type="number" class="form-input" id="inputRisk" value="2" step="0.5" min="0.5" max="5">
                </div>
                
                <button class="btn btn-primary" id="btnCalculate">Calculate Risk</button>
            </section>
            
            <!-- Position Info (shown after calculation) -->
            <section class="sidebar-section" id="positionSection" style="display: none;">
                <div class="section-title">Position</div>
                
                <div class="data-grid">
                    <div class="data-item">
                        <span class="data-label">Size</span>
                        <span class="data-value" id="positionSize">--</span>
                    </div>
                    <div class="data-item">
                        <span class="data-label">Risk $</span>
                        <span class="data-value negative" id="positionRisk">--</span>
                    </div>
                    <div class="data-item">
                        <span class="data-label">R-Multiple</span>
                        <span class="data-value" id="positionR">0R</span>
                    </div>
                    <div class="data-item">
                        <span class="data-label">Unrealized</span>
                        <span class="data-value" id="positionPnl">$0</span>
                    </div>
                </div>
            </section>
            
            <!-- Stops -->
            <section class="sidebar-section" id="stopsSection" style="display: none;">
                <div class="section-title">Stop Levels</div>
                <div class="level-list" id="stopsList"></div>
            </section>
            
            <!-- Targets -->
            <section class="sidebar-section" id="targetsSection" style="display: none;">
                <div class="section-title">Targets</div>
                <div class="level-list" id="targetsList"></div>
            </section>
            
            <!-- Guarding -->
            <section class="sidebar-section" id="guardingSection" style="display: none;">
                <div class="section-title">Trailing Guard</div>
                <div class="guarding-status" id="guardingStatus">
                    <div class="guarding-indicator"></div>
                    <div class="guarding-info">
                        <div class="guarding-label">Guard Level</div>
                        <div class="guarding-value" id="guardingValue">--</div>
                    </div>
                </div>
                <button class="btn" id="btnActivateGuard" style="margin-top: 12px;">
                    Activate Guard
                </button>
            </section>
        </aside>
    </div>
    
    <script src="chart.js"></script>
    <script src="api-client.js"></script>
    <script src="volume-profile.js"></script>
    <script>
        // State
        let state = {
            symbol: 'BTCUSDT',
            timeframe: '4h',
            direction: 'long',
            entryPrice: 0,
            currentPrice: 0,
            balance: 100000,
            riskPct: 2,
            positionSize: 0,
            riskAmount: 0,
            stops: [],
            targets: [],
            guardingActive: false,
            guardingLevel: 0,
            guardingSlope: 0,
            vpvrData: null,
            sessionId: null,
        };
        
        let chart = null;
        let volumeProfile = null;
        
        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            // Create chart
            chart = new BastionChart('chart');
            
            // Create volume profile overlay
            volumeProfile = new VolumeProfileOverlay(document.getElementById('chart'));
            
            // Check for saved session
            checkSavedSession();
            
            // Load initial data
            await loadChartData();
            
            // Start price polling
            api.startPricePolling(state.symbol, 3000);
            api.onPriceUpdate(handlePriceUpdate);
            
            // Setup event listeners
            setupEventListeners();
        });
        
        function checkSavedSession() {
            try {
                const saved = localStorage.getItem('bastion_session');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    if (parsed.entryPrice && Date.now() - parsed.timestamp < 86400000) {
                        // Session less than 24h old
                        if (confirm('Resume previous session?')) {
                            Object.assign(state, parsed);
                            restoreSession();
                        } else {
                            localStorage.removeItem('bastion_session');
                        }
                    }
                }
            } catch (e) {
                console.warn('Failed to restore session:', e);
            }
        }
        
        function restoreSession() {
            // Update UI with saved state
            document.getElementById('inputSymbol').value = state.symbol;
            document.getElementById('inputEntry').value = state.entryPrice;
            document.getElementById('inputBalance').value = state.balance;
            document.getElementById('inputRisk').value = state.riskPct;
            setDirection(state.direction);
            
            // Show sections
            document.getElementById('positionSection').style.display = 'block';
            document.getElementById('stopsSection').style.display = 'block';
            document.getElementById('targetsSection').style.display = 'block';
            document.getElementById('guardingSection').style.display = 'block';
            
            updatePositionDisplay();
            updateStopsDisplay();
            updateTargetsDisplay();
        }
        
        function saveSession() {
            try {
                const toSave = {
                    ...state,
                    timestamp: Date.now(),
                };
                localStorage.setItem('bastion_session', JSON.stringify(toSave));
            } catch (e) {
                console.warn('Failed to save session:', e);
            }
        }
        
        function setupEventListeners() {
            // Direction toggle
            document.getElementById('btnLong').addEventListener('click', () => setDirection('long'));
            document.getElementById('btnShort').addEventListener('click', () => setDirection('short'));
            
            // Symbol change
            document.getElementById('inputSymbol').addEventListener('change', async (e) => {
                state.symbol = e.target.value;
                document.getElementById('symbolName').textContent = state.symbol;
                api.stopPricePolling();
                await loadChartData();
                api.startPricePolling(state.symbol, 3000);
            });
            
            // Timeframe buttons
            document.querySelectorAll('.timeframe-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    document.querySelectorAll('.timeframe-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    state.timeframe = e.target.dataset.tf;
                    await loadChartData();
                });
            });
            
            // Calculate button
            document.getElementById('btnCalculate').addEventListener('click', calculateRisk);
            
            // Activate guard
            document.getElementById('btnActivateGuard').addEventListener('click', activateGuard);
            
            // Balance/risk input changes
            document.getElementById('inputBalance').addEventListener('change', (e) => {
                state.balance = parseFloat(e.target.value) || 100000;
            });
            
            document.getElementById('inputRisk').addEventListener('change', (e) => {
                state.riskPct = parseFloat(e.target.value) || 2;
            });
        }
        
        function setDirection(dir) {
            state.direction = dir;
            document.getElementById('btnLong').classList.toggle('active', dir === 'long');
            document.getElementById('btnShort').classList.toggle('active', dir === 'short');
            document.getElementById('btnLong').classList.toggle('long', dir === 'long');
            document.getElementById('btnShort').classList.toggle('short', dir === 'short');
        }
        
        async function loadChartData() {
            chart.setTimeframe(state.timeframe);
            const bars = await chart.loadData(state.symbol, state.timeframe, 200);
            if (bars.length > 0) {
                const lastBar = bars[bars.length - 1];
                state.currentPrice = lastBar.close;
                updatePriceDisplay(state.currentPrice, 0);
            }
        }
        
        function handlePriceUpdate(data) {
            state.currentPrice = data.price;
            updatePriceDisplay(data.price, data.change_24h_pct);
            updatePositionPnl();
        }
        
        function updatePriceDisplay(price, changePct) {
            document.getElementById('symbolPrice').textContent = formatPrice(price);
            
            const changeEl = document.getElementById('symbolChange');
            changeEl.textContent = `${changePct >= 0 ? '+' : ''}${changePct.toFixed(2)}%`;
            changeEl.className = `symbol-change ${changePct >= 0 ? 'positive' : 'negative'}`;
        }
        
        async function calculateRisk() {
            const entryInput = document.getElementById('inputEntry').value;
            state.entryPrice = entryInput ? parseFloat(entryInput) : state.currentPrice;
            
            if (!state.entryPrice) {
                alert('Waiting for price data...');
                return;
            }
            
            // Show loading state
            const btn = document.getElementById('btnCalculate');
            btn.disabled = true;
            btn.textContent = 'Calculating...';
            
            try {
                const response = await api.calculate({
                    symbol: state.symbol,
                    entry_price: state.entryPrice,
                    direction: state.direction,
                    timeframe: state.timeframe,
                    account_balance: state.balance,
                    risk_per_trade_pct: state.riskPct,
                });
                
                if (response.error) {
                    alert(response.error);
                    return;
                }
                
                console.log('API Response:', response);
                
                // Update state from API response
                state.positionSize = response.position_size || 0;
                state.riskAmount = response.risk_amount || (state.balance * state.riskPct / 100);
                state.stops = response.stops || [];
                state.targets = response.targets || [];
                
                // Guarding line parameters from API
                if (response.guarding_line) {
                    state.guardingSlope = response.guarding_line.slope || (state.entryPrice * 0.001);
                    state.guardingLevel = response.guarding_line.current_level || state.entryPrice;
                }
                
                // VPVR data from API
                if (response.vpvr) {
                    state.vpvrData = response.vpvr;
                }
                
                // Draw levels on chart
                chart.setTimeframe(state.timeframe);
                chart.drawRiskLevels(response, state.entryPrice);
                
                // Draw projected (inactive) guarding line
                const slope = state.guardingSlope || (state.entryPrice * 0.001);
                chart.drawProjectedGuardingLine(state.entryPrice, slope, state.direction, 30);
                
                // Draw volume profile if available
                if (state.vpvrData && volumeProfile) {
                    const prices = state.stops.map(s => s.price).concat(state.targets.map(t => t.price));
                    prices.push(state.entryPrice, state.currentPrice);
                    const minPrice = Math.min(...prices) * 0.98;
                    const maxPrice = Math.max(...prices) * 1.02;
                    volumeProfile.setData(state.vpvrData, { min: minPrice, max: maxPrice });
                }
                
                // Update UI
                updatePositionDisplay();
                updateStopsDisplay();
                updateTargetsDisplay();
                updateGuardingDisplay();
                
                // Show sections
                document.getElementById('positionSection').style.display = 'block';
                document.getElementById('stopsSection').style.display = 'block';
                document.getElementById('targetsSection').style.display = 'block';
                document.getElementById('guardingSection').style.display = 'block';
                
                // Save session
                saveSession();
                
            } catch (e) {
                console.error('Calculate failed:', e);
                alert('Calculation failed: ' + e.message);
            } finally {
                btn.disabled = false;
                btn.textContent = 'Calculate Risk';
            }
        }
        
        function updateGuardingDisplay() {
            const level = state.guardingLevel || state.entryPrice;
            document.getElementById('guardingValue').textContent = formatPrice(level);
        }
        
        function updatePositionDisplay() {
            document.getElementById('positionSize').textContent = state.positionSize.toFixed(4);
            document.getElementById('positionRisk').textContent = `-$${state.riskAmount.toFixed(0)}`;
            updatePositionPnl();
        }
        
        function updatePositionPnl() {
            if (!state.entryPrice || !state.positionSize) return;
            
            const pnl = state.direction === 'long'
                ? (state.currentPrice - state.entryPrice) * state.positionSize
                : (state.entryPrice - state.currentPrice) * state.positionSize;
            
            const rMultiple = state.riskAmount > 0 ? pnl / state.riskAmount : 0;
            
            const pnlEl = document.getElementById('positionPnl');
            pnlEl.textContent = `${pnl >= 0 ? '+' : ''}$${pnl.toFixed(0)}`;
            pnlEl.className = `data-value ${pnl >= 0 ? 'positive' : 'negative'}`;
            
            const rEl = document.getElementById('positionR');
            rEl.textContent = `${rMultiple >= 0 ? '+' : ''}${rMultiple.toFixed(1)}R`;
            rEl.className = `data-value ${rMultiple >= 0 ? 'positive' : 'negative'}`;
        }
        
        function updateStopsDisplay() {
            const container = document.getElementById('stopsList');
            
            // Entry
            let html = `
                <div class="level-item entry">
                    <div class="level-info">
                        <span class="level-type">Entry</span>
                        <span class="level-price">${formatPrice(state.entryPrice)}</span>
                    </div>
                </div>
            `;
            
            // Stops
            state.stops.forEach(stop => {
                const dist = ((stop.price - state.entryPrice) / state.entryPrice * 100).toFixed(2);
                const type = stop.type || 'stop';
                html += `
                    <div class="level-item ${type === 'safety_net' ? 'safety' : 'stop'}">
                        <div class="level-info">
                            <span class="level-type">${stop.type || 'Stop'}</span>
                            <span class="level-price">${formatPrice(stop.price)}</span>
                        </div>
                        <span class="level-distance">${dist}%</span>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        function updateTargetsDisplay() {
            const container = document.getElementById('targetsList');
            
            let html = '';
            state.targets.forEach((target, i) => {
                const dist = ((target.price - state.entryPrice) / state.entryPrice * 100).toFixed(2);
                html += `
                    <div class="level-item target">
                        <div class="level-info">
                            <span class="level-type">T${i + 1} (${target.exit_percentage || 33}%)</span>
                            <span class="level-price">${formatPrice(target.price)}</span>
                        </div>
                        <span class="level-distance">+${dist}%</span>
                    </div>
                `;
            });
            
            container.innerHTML = html || '<div class="empty-state"><span class="empty-state-desc">No targets</span></div>';
        }
        
        function activateGuard() {
            if (state.guardingActive) return;
            
            state.guardingActive = true;
            
            // Calculate guard level based on current price with buffer
            state.guardingLevel = state.direction === 'long'
                ? state.currentPrice * 0.98
                : state.currentPrice * 1.02;
            
            // Calculate slope (price increase per bar)
            const slope = state.guardingSlope || (state.entryPrice * 0.001);
            
            // Draw ANGLED guarding line
            chart.drawAngledGuardingLine(state.guardingLevel, slope, state.direction, 30);
            
            const statusEl = document.getElementById('guardingStatus');
            statusEl.classList.add('active');
            
            document.getElementById('guardingValue').textContent = formatPrice(state.guardingLevel);
            document.getElementById('btnActivateGuard').textContent = 'Guard Active';
            document.getElementById('btnActivateGuard').disabled = true;
            
            // Save session with guard active
            saveSession();
        }
        
        function formatPrice(price) {
            if (!price) return '--';
            return price >= 1000
                ? price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })
                : price.toFixed(2);
        }
    </script>
</body>
</html>
